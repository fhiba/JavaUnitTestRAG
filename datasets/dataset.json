[
  {
    "class": "public class Adder {\n    public int add(int a, int b) {\n        return a + b;\n    }\n}",
    "tests": "public class AdderTest {\n    @Test\n    public void testAdd() {\n        Adder adder = new Adder();\n        assertEquals(5, adder.add(2, 3));\n    }\n}",
    "description": "A simple class that adds two integers together and returns the result."
  },
  {
    "class": "public class Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    public int subtract(int a, int b) {\n        return a - b;\n    }\n    \n    public int multiply(int a, int b) {\n        return a * b;\n    }\n    \n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException(\"Cannot divide by zero\");\n        }\n        return a / b;\n    }\n}",
    "tests": "public class CalculatorTest {\n    private Calculator calculator;\n    \n    @Before\n    public void setUp() {\n        calculator = new Calculator();\n    }\n    \n    @Test\n    public void testAdd() {\n        assertEquals(5, calculator.add(2, 3));\n    }\n    \n    @Test\n    public void testSubtract() {\n        assertEquals(2, calculator.subtract(5, 3));\n    }\n    \n    @Test\n    public void testMultiply() {\n        assertEquals(15, calculator.multiply(5, 3));\n    }\n    \n    @Test\n    public void testDivide() {\n        assertEquals(2, calculator.divide(6, 3));\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testDivideByZero() {\n        calculator.divide(5, 0);\n    }\n}",
    "description": "A basic calculator class that performs fundamental arithmetic operations: addition, subtraction, multiplication, and division with exception handling for division by zero."
  },
  {
    "class": "public class StringUtils {\n    public String reverse(String input) {\n        if (input == null) {\n            return null;\n        }\n        \n        StringBuilder reversed = new StringBuilder();\n        for (int i = input.length() - 1; i >= 0; i--) {\n            reversed.append(input.charAt(i));\n        }\n        \n        return reversed.toString();\n    }\n    \n    public boolean isPalindrome(String input) {\n        if (input == null) {\n            return false;\n        }\n        \n        String cleaned = input.toLowerCase().replaceAll(\"\\\\s+\", \"\");\n        String reversed = reverse(cleaned);\n        return cleaned.equals(reversed);\n    }\n}",
    "tests": "public class StringUtilsTest {\n    private StringUtils stringUtils;\n    \n    @Before\n    public void setUp() {\n        stringUtils = new StringUtils();\n    }\n    \n    @Test\n    public void testReverse() {\n        assertEquals(\"olleh\", stringUtils.reverse(\"hello\"));\n        assertEquals(\"\", stringUtils.reverse(\"\"));\n        assertNull(stringUtils.reverse(null));\n    }\n    \n    @Test\n    public void testIsPalindrome() {\n        assertTrue(stringUtils.isPalindrome(\"racecar\"));\n        assertTrue(stringUtils.isPalindrome(\"A man a plan a canal Panama\"));\n        assertFalse(stringUtils.isPalindrome(\"hello\"));\n        assertFalse(stringUtils.isPalindrome(null));\n        assertTrue(stringUtils.isPalindrome(\"\"));\n    }\n}",
    "description": "A utility class for string operations including reversing strings and checking if a string is a palindrome with case-insensitive comparison and whitespace handling."
  },
  {
    "class": "public class User {\n    private String username;\n    private String email;\n    private int age;\n    \n    public User(String username, String email, int age) {\n        this.username = username;\n        this.email = email;\n        this.age = age;\n    }\n    \n    public String getUsername() {\n        return username;\n    }\n    \n    public String getEmail() {\n        return email;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    public boolean isAdult() {\n        return age >= 18;\n    }\n    \n    public void setEmail(String email) {\n        this.email = email;\n    }\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        \n        User user = (User) obj;\n        return age == user.age && \n               Objects.equals(username, user.username) && \n               Objects.equals(email, user.email);\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(username, email, age);\n    }\n}",
    "tests": "public class UserTest {\n    \n    @Test\n    public void testUserCreation() {\n        User user = new User(\"john_doe\", \"john@example.com\", 25);\n        assertEquals(\"john_doe\", user.getUsername());\n        assertEquals(\"john@example.com\", user.getEmail());\n        assertEquals(25, user.getAge());\n    }\n    \n    @Test\n    public void testIsAdult() {\n        User minor = new User(\"alice\", \"alice@example.com\", 15);\n        User adult = new User(\"bob\", \"bob@example.com\", 18);\n        User older = new User(\"charlie\", \"charlie@example.com\", 30);\n        \n        assertFalse(minor.isAdult());\n        assertTrue(adult.isAdult());\n        assertTrue(older.isAdult());\n    }\n    \n    @Test\n    public void testSetEmail() {\n        User user = new User(\"john_doe\", \"john@example.com\", 25);\n        user.setEmail(\"john.doe@company.com\");\n        assertEquals(\"john.doe@company.com\", user.getEmail());\n    }\n    \n    @Test\n    public void testEquals() {\n        User user1 = new User(\"john\", \"john@example.com\", 25);\n        User user2 = new User(\"john\", \"john@example.com\", 25);\n        User user3 = new User(\"jane\", \"jane@example.com\", 30);\n        \n        assertEquals(user1, user2);\n        assertNotEquals(user1, user3);\n        assertNotEquals(user1, null);\n    }\n}",
    "description": "A User class that represents a user with attributes like username, email, and age. It includes methods to determine if a user is an adult and properly implements equals and hashCode methods."
  },
  {
    "class": "public class ShoppingCart {\n    private List<Item> items;\n    \n    public ShoppingCart() {\n        this.items = new ArrayList<>();\n    }\n    \n    public void addItem(Item item) {\n        items.add(item);\n    }\n    \n    public void removeItem(Item item) {\n        items.remove(item);\n    }\n    \n    public int getItemCount() {\n        return items.size();\n    }\n    \n    public double calculateTotal() {\n        return items.stream()\n                .mapToDouble(Item::getPrice)\n                .sum();\n    }\n    \n    public void clear() {\n        items.clear();\n    }\n    \n    public List<Item> getItems() {\n        return new ArrayList<>(items);\n    }\n}",
    "tests": "public class ShoppingCartTest {\n    private ShoppingCart cart;\n    private Item item1;\n    private Item item2;\n    \n    @Before\n    public void setUp() {\n        cart = new ShoppingCart();\n        item1 = new Item(\"Book\", 15.99);\n        item2 = new Item(\"Pen\", 2.99);\n    }\n    \n    @Test\n    public void testAddItem() {\n        cart.addItem(item1);\n        assertEquals(1, cart.getItemCount());\n        assertEquals(item1, cart.getItems().get(0));\n    }\n    \n    @Test\n    public void testRemoveItem() {\n        cart.addItem(item1);\n        cart.addItem(item2);\n        cart.removeItem(item1);\n        assertEquals(1, cart.getItemCount());\n        assertEquals(item2, cart.getItems().get(0));\n    }\n    \n    @Test\n    public void testCalculateTotal() {\n        cart.addItem(item1);\n        cart.addItem(item2);\n        assertEquals(18.98, cart.calculateTotal(), 0.001);\n    }\n    \n    @Test\n    public void testClear() {\n        cart.addItem(item1);\n        cart.addItem(item2);\n        cart.clear();\n        assertEquals(0, cart.getItemCount());\n        assertTrue(cart.getItems().isEmpty());\n    }\n}",
    "description": "A shopping cart implementation that manages a collection of items with functionality to add, remove, count items, calculate the total price, and clear the cart."
  },
  {
    "class": "public class BankAccount {\n    private String accountNumber;\n    private double balance;\n    private String owner;\n    \n    public BankAccount(String accountNumber, String owner) {\n        this.accountNumber = accountNumber;\n        this.owner = owner;\n        this.balance = 0.0;\n    }\n    \n    public void deposit(double amount) {\n        if (amount <= 0) {\n            throw new IllegalArgumentException(\"Deposit amount must be positive\");\n        }\n        balance += amount;\n    }\n    \n    public void withdraw(double amount) {\n        if (amount <= 0) {\n            throw new IllegalArgumentException(\"Withdrawal amount must be positive\");\n        }\n        if (amount > balance) {\n            throw new InsufficientFundsException(\"Not enough funds in account\");\n        }\n        balance -= amount;\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n    \n    public String getAccountNumber() {\n        return accountNumber;\n    }\n    \n    public String getOwner() {\n        return owner;\n    }\n}",
    "tests": "public class BankAccountTest {\n    private BankAccount account;\n    \n    @Before\n    public void setUp() {\n        account = new BankAccount(\"123456789\", \"John Doe\");\n    }\n    \n    @Test\n    public void testNewAccountHasZeroBalance() {\n        assertEquals(0.0, account.getBalance(), 0.001);\n    }\n    \n    @Test\n    public void testDeposit() {\n        account.deposit(100.0);\n        assertEquals(100.0, account.getBalance(), 0.001);\n        \n        account.deposit(50.0);\n        assertEquals(150.0, account.getBalance(), 0.001);\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testNegativeDeposit() {\n        account.deposit(-100.0);\n    }\n    \n    @Test\n    public void testWithdraw() {\n        account.deposit(100.0);\n        account.withdraw(40.0);\n        assertEquals(60.0, account.getBalance(), 0.001);\n    }\n    \n    @Test(expected = InsufficientFundsException.class)\n    public void testOverdraft() {\n        account.deposit(100.0);\n        account.withdraw(150.0);\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testNegativeWithdrawal() {\n        account.withdraw(-50.0);\n    }\n    \n    @Test\n    public void testGetAccountDetailsReturnCorrectValues() {\n        assertEquals(\"123456789\", account.getAccountNumber());\n        assertEquals(\"John Doe\", account.getOwner());\n    }\n}",
    "description": "A bank account class that manages financial operations including deposits and withdrawals with proper validation and exception handling for negative amounts and insufficient funds."
  },
  {
    "class": "public class Book {\n    private String title;\n    private String author;\n    private Integer pages;\n    private Boolean available;\n\n    public Book(String title, String author, Integer pages) {\n        this.title = title;\n        this.author = author;\n        this.pages = pages;\n        this.available = true;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public String getAuthor() {\n        return author;\n    }\n\n    public Integer getPages() {\n        return pages;\n    }\n\n    public Boolean getAvailable() {\n        return available;\n    }\n\n    public void borrow() {\n        if (!available) {\n            throw new BookAlreadyBorrowedException(\"Book is already borrowed\");\n        }\n\n        this.available = false;\n    }\n\n    public void turnPage() {\n        System.out.println(\"Turning the page ...\");\n    }\n}",
    "tests": "class BookTest {\n\n    @Test\n    void shouldCreateNewBook() {\n        Book effectiveJava = new Book(\"Effective Java\", \"Joshua Bloch\", 377);\n\n        assertThat(effectiveJava.getAuthor()).isEqualTo(\"Joshua Bloch\");\n        assertThat(effectiveJava.getTitle()).isEqualTo(\"Effective Java\");\n        assertThat(effectiveJava.getPages()).isEqualTo(377);\n    }\n\n    @Test\n    void shouldNotBeAbleToCreateBookWithNegativeNumberOfPages() {\n        assertThatThrownBy(() -> new Book(\"Effective Java\", \"Joshua Bloch\", -42))\n                .isInstanceOf(NegativeNumberOfPagesException.class)\n                .hasMessage(\"Number of pages must be positive\");\n    }\n\n    @Test\n    void shouldBorrowBook() {\n        Book effectiveJava = new Book(\"Effective Java\", \"Joshua Bloch\", 377);\n\n        assertThat(effectiveJava.getAvailable()).isTrue();\n\n        effectiveJava.borrow();\n\n        assertThat(effectiveJava.getAvailable()).isFalse();\n    }\n\n    @Test\n    void shouldNotBeAbleToBorrowBookThatIsAlreadyBorrowed() {\n        Book effectiveJava = new Book(\"Effective Java\", \"Joshua Bloch\", 377);\n\n        effectiveJava.borrow();\n\n        assertThatThrownBy(() -> effectiveJava.borrow())\n                .isInstanceOf(BookAlreadyBorrowedException.class)\n                .hasMessage(\"Book is already borrowed\");\n    }\n}",
    "description": "A Book class that represents a book with attributes like title, author, pages, and availability status. It includes methods for borrowing books and validation for positive page count."
  },
  {
    "class": "public class UserService {\n\n    private final UserRepository userRepository;\n\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    public User registerUser(User user) {\n\n        if (userRepository.findByEmail(user.getEmail()).isPresent()) {\n            throw new DuplicateUserException(\"Email is already taken\");\n        }\n\n        if (user.getAge() < 18) {\n            throw new InvalidUserAgeException(\"User has to be at least 18 years old\");\n        }\n\n        user.setCreatedAt(LocalDateTime.now());\n\n        return userRepository.save(user);\n    }\n\n    public User getUserByEmail(String email) {\n        return userRepository.findByEmail(email)\n                .orElseThrow(() -> new UserNotFoundException(\"User not found with email: \" + email));\n    }\n\n    public List<User> findAllUsersOrderedByCreationDateDescending() {\n        List<User> users = userRepository.findAll();\n\n        users.sort((a, b) -> b.getCreatedAt().compareTo(a.getCreatedAt()));\n\n        return users;\n    }\n\n    public void deleteUser(String email) {\n        User user = getUserByEmail(email);\n        userRepository.delete(user);\n    }\n}",
    "tests": "class UserServiceTest {\n\n    private UserService cut;\n    private UserRepository userRepository;\n\n    @BeforeEach\n    void setUp() {\n        userRepository = mock(UserRepository.class);\n        cut = new UserService(userRepository);\n    }\n\n    @Test\n    void shouldRegisterNewUser() {\n        User userToRegister = new User(\"duke@spring.io\", 42);\n        User expectedUser = new User(\"duke@spring.io\", 42);\n        expectedUser.setId(42L);\n\n        when(userRepository.findByEmail(userToRegister.getEmail())).thenReturn(Optional.empty());\n        when(userRepository.save(any(User.class))).thenReturn(expectedUser);\n\n        User result = cut.registerUser(userToRegister);\n\n        verify(userRepository).findByEmail(userToRegister.getEmail());\n        verify(userRepository).save(userToRegister);\n\n        assertThat(result.getId()).isEqualTo(42L);\n        assertThat(result.getEmail()).isEqualTo(\"duke@spring.io\");\n        assertThat(result.getAge()).isEqualTo(42);\n        assertThat(result.getCreatedAt()).isNotNull();\n    }\n\n    @Test\n    void shouldFailWhenRegisterNewUserWithDuplicateEmail() {\n        User userToRegister = new User(\"duke@spring.io\", 42);\n        User existingUser = new User(\"duke@spring.io\", 42);\n\n        when(userRepository.findByEmail(userToRegister.getEmail())).thenReturn(Optional.of(existingUser));\n\n        assertThatThrownBy(() -> cut.registerUser(userToRegister))\n                .isInstanceOf(DuplicateUserException.class)\n                .hasMessage(\"Email is already taken\");\n\n        verify(userRepository).findByEmail(userToRegister.getEmail());\n        verifyNoMoreInteractions(userRepository);\n    }\n\n    @Test\n    void shouldFailWhenRegisterNewUserWithAgeLessThan18() {\n        User userToRegister = new User(\"duke@spring.io\", 16);\n\n        when(userRepository.findByEmail(userToRegister.getEmail())).thenReturn(Optional.empty());\n\n        assertThatThrownBy(() -> cut.registerUser(userToRegister))\n                .isInstanceOf(InvalidUserAgeException.class)\n                .hasMessage(\"User has to be at least 18 years old\");\n\n        verify(userRepository).findByEmail(userToRegister.getEmail());\n        verifyNoMoreInteractions(userRepository);\n    }\n\n    @Test\n    void shouldGetUserByEmail() {\n        User expectedUser = new User(\"duke@spring.io\", 42);\n        expectedUser.setId(42L);\n\n        when(userRepository.findByEmail(\"duke@spring.io\")).thenReturn(Optional.of(expectedUser));\n\n        User result = cut.getUserByEmail(\"duke@spring.io\");\n\n        verify(userRepository).findByEmail(\"duke@spring.io\");\n\n        assertThat(result.getId()).isEqualTo(42L);\n        assertThat(result.getEmail()).isEqualTo(\"duke@spring.io\");\n        assertThat(result.getAge()).isEqualTo(42);\n    }\n\n    @Test\n    void shouldFailWhenUserEmailDoesNotExist() {\n        when(userRepository.findByEmail(\"duke@spring.io\")).thenReturn(Optional.empty());\n\n        assertThatThrownBy(() -> cut.getUserByEmail(\"duke@spring.io\"))\n                .isInstanceOf(UserNotFoundException.class)\n                .hasMessage(\"User not found with email: duke@spring.io\");\n\n        verify(userRepository).findByEmail(\"duke@spring.io\");\n    }\n\n    @Test\n    void shouldDeleteUser() {\n        User expectedUser = new User(\"duke@spring.io\", 42);\n        expectedUser.setId(42L);\n\n        when(userRepository.findByEmail(\"duke@spring.io\")).thenReturn(Optional.of(expectedUser));\n\n        cut.deleteUser(\"duke@spring.io\");\n\n        verify(userRepository).findByEmail(\"duke@spring.io\");\n        verify(userRepository).delete(expectedUser);\n    }\n\n    @Test\n    void shouldFailWhenTryingToDeleteNonExistingUser() {\n        when(userRepository.findByEmail(\"duke@spring.io\")).thenReturn(Optional.empty());\n\n        assertThatThrownBy(() -> cut.deleteUser(\"duke@spring.io\"))\n                .isInstanceOf(UserNotFoundException.class)\n                .hasMessage(\"User not found with email: duke@spring.io\");\n\n        verify(userRepository).findByEmail(\"duke@spring.io\");\n        verifyNoMoreInteractions(userRepository);\n    }\n\n    @Test\n    void shouldReturnAllUsersOrderedByCreationDateDescending() {\n        User userOne = new User(\"duke@spring.io\", 42);\n        userOne.setCreatedAt(LocalDateTime.now().minusDays(2));\n\n        User userTwo = new User(\"hello@world.io\", 42);\n        userTwo.setCreatedAt(LocalDateTime.now());\n\n        User userThree = new User(\"john@doe.io\", 42);\n        userThree.setCreatedAt(LocalDateTime.now().minusDays(4));\n\n        List<User> userList = Arrays.asList(userOne, userTwo, userThree);\n\n        when(userRepository.findAll()).thenReturn(userList);\n\n        List<User> result = cut.findAllUsersOrderedByCreationDateDescending();\n\n        verify(userRepository).findAll();\n\n        assertThat(result).hasSize(3);\n        assertThat(result.get(0).getEmail()).isEqualTo(userTwo.getEmail());\n        assertThat(result.get(1).getEmail()).isEqualTo(userOne.getEmail());\n        assertThat(result.get(2).getEmail()).isEqualTo(userThree.getEmail());\n    }\n}",
    "description": "A service class that manages user operations including registration, retrieval, deletion, and listing with validation for user age and email uniqueness."
  },
  {
    "class": "public class TodoBusinessImpl {\n\n    private final TodoService todoService;\n\n    public TodoBusinessImpl(TodoService todoService) {\n        this.todoService = todoService;\n    }\n\n    public List<String> retrieveTodosRelatedToSpring(String user) {\n        List<String> filteredTodos = new ArrayList<>();\n        List<String> allTodos = todoService.retrieveTodos(user);\n\n        for (String todo : allTodos) {\n            if (todo.contains(\"Spring\")) {\n                filteredTodos.add(todo);\n            }\n        }\n\n        return filteredTodos;\n    }\n\n    public void deleteTodosNotRelatedToSpring(String user) {\n        List<String> allTodos = todoService.retrieveTodos(user);\n\n        for (String todo : allTodos) {\n            if (!todo.contains(\"Spring\")) {\n                todoService.deleteTodo(todo);\n            }\n        }\n    }\n}",
    "tests": "class TodoBusinessImplMockTest {\n\n    private TodoService todoServiceMock;\n    private TodoBusinessImpl todoBusinessImpl;\n\n    @BeforeEach\n    void setUp() {\n        todoServiceMock = mock(TodoService.class);\n        todoBusinessImpl = new TodoBusinessImpl(todoServiceMock);\n    }\n\n    @Test\n    void retrieveTodosRelatedToSpring_With_Empty_List() {\n        given(todoServiceMock.retrieveTodos(\"Duke\")).willReturn(Collections.emptyList());\n\n        List<String> filteredTodos = todoBusinessImpl.retrieveTodosRelatedToSpring(\"Duke\");\n\n        assertThat(filteredTodos).isEmpty();\n    }\n\n    @Test\n    void retrieveTodosRelatedToSpring_With_Some_Values_Matching() {\n        given(todoServiceMock.retrieveTodos(\"Duke\")).willReturn(\n                Arrays.asList(\"Learn Spring\", \"Learn JPA\", \"Learn Spring Security\"));\n\n        List<String> filteredTodos = todoBusinessImpl.retrieveTodosRelatedToSpring(\"Duke\");\n\n        assertThat(filteredTodos).hasSize(2);\n        assertThat(filteredTodos).containsExactly(\"Learn Spring\", \"Learn Spring Security\");\n    }\n\n    @Test\n    void deleteTodosNotRelatedToSpring_Should_Delete_Using_the_Service() {\n        given(todoServiceMock.retrieveTodos(\"Duke\")).willReturn(\n                Arrays.asList(\"Learn Spring\", \"Learn JPA\", \"Learn Spring Security\"));\n\n        todoBusinessImpl.deleteTodosNotRelatedToSpring(\"Duke\");\n\n        verify(todoServiceMock).deleteTodo(\"Learn JPA\");\n        verify(todoServiceMock, never()).deleteTodo(\"Learn Spring\");\n        verify(todoServiceMock, never()).deleteTodo(\"Learn Spring Security\");\n    }\n\n    @Test\n    void deleteTodosNotRelatedToSpring_Should_Not_Call_Delete_With_EmptyList() {\n        given(todoServiceMock.retrieveTodos(\"Duke\")).willReturn(Collections.emptyList());\n\n        todoBusinessImpl.deleteTodosNotRelatedToSpring(\"Duke\");\n\n        verify(todoServiceMock, never()).deleteTodo(anyString());\n    }\n}",
    "description": "A business logic class that filters and manages todo items related to Spring, including retrieving Spring-related todos and deleting todos not related to Spring."
  },
  {
    "class": "public class WeatherService {\n\n    private final WeatherClient weatherClient;\n    private final AuditLog auditLog;\n\n    public WeatherService(WeatherClient weatherClient, AuditLog auditLog) {\n        this.weatherClient = weatherClient;\n        this.auditLog = auditLog;\n    }\n\n    public String getWeatherForecast(String city) {\n\n        if (city == null || city.isBlank()) {\n            throw new InvalidCityNameException(\"City name must not be null or blank\");\n        }\n\n        try {\n            String forecast = weatherClient.requestForecastForCity(city);\n            auditLog.logRequest(city, forecast);\n            return forecast;\n        } catch (Exception e) {\n            auditLog.logError(city, e.getMessage());\n            throw new WeatherServiceException(\"Could not determine weather forecast\", e);\n        }\n    }\n}",
    "tests": "class WeatherServiceTest {\n\n    private WeatherService cut;\n    private WeatherClient weatherClientMock;\n    private AuditLog auditLogMock;\n\n    @BeforeEach\n    void setUp() {\n        weatherClientMock = mock(WeatherClient.class);\n        auditLogMock = mock(AuditLog.class);\n        cut = new WeatherService(weatherClientMock, auditLogMock);\n    }\n\n    @Test\n    void shouldReturnWeatherForecast() {\n        when(weatherClientMock.requestForecastForCity(\"Hamburg\")).thenReturn(\"Sunshine expected for tomorrow\");\n\n        String result = cut.getWeatherForecast(\"Hamburg\");\n\n        verify(weatherClientMock).requestForecastForCity(\"Hamburg\");\n        verify(auditLogMock).logRequest(\"Hamburg\", \"Sunshine expected for tomorrow\");\n\n        assertThat(result).isEqualTo(\"Sunshine expected for tomorrow\");\n    }\n\n    @Test\n    void shouldRejectEmptyCityName() {\n        assertThrows(InvalidCityNameException.class, () -> cut.getWeatherForecast(\"\"), \"City name must not be null or blank\");\n        verifyNoInteractions(weatherClientMock);\n        verifyNoInteractions(auditLogMock);\n    }\n\n    @Test\n    void shouldRejectNullCityName() {\n        InvalidCityNameException exception = assertThrows(InvalidCityNameException.class, () -> cut.getWeatherForecast(null));\n\n        assertThat(exception.getMessage()).isEqualTo(\"City name must not be null or blank\");\n\n        verifyNoInteractions(weatherClientMock);\n        verifyNoInteractions(auditLogMock);\n    }\n\n    @Test\n    void shouldPropagateExceptionWhenClientFails() {\n        when(weatherClientMock.requestForecastForCity(\"Hamburg\"))\n                .thenThrow(new RuntimeException(\"Backend not available\"));\n\n        WeatherServiceException exception = assertThrows(WeatherServiceException.class, () -> cut.getWeatherForecast(\"Hamburg\"));\n\n        assertThat(exception.getMessage()).isEqualTo(\"Could not determine weather forecast\");\n        assertThat(exception.getCause()).isInstanceOf(RuntimeException.class);\n        assertThat(exception.getCause().getMessage()).isEqualTo(\"Backend not available\");\n\n        verify(auditLogMock).logError(\"Hamburg\", \"Backend not available\");\n    }\n}",
    "description": "A weather service that retrieves weather forecasts for cities, with validation for city names and error handling for client failures while maintaining an audit log of requests and errors."
  },
  {
    "class": "public class CartService {\n\n    private final ProductVerifier productVerifier;\n\n    public CartService(ProductVerifier productVerifier) {\n        this.productVerifier = productVerifier;\n    }\n\n    public String addProductToCart(String productId) {\n        if (!productVerifier.isValid(productId)) {\n            throw new IllegalArgumentException(\"Not a valid product\");\n        }\n\n        String result = productVerifier.getDetails(productId);\n\n        System.out.println(\"Product added to cart: \" + result);\n\n        return \"SUCCESS\";\n    }\n}",
    "tests": "class CartServiceTest {\n\n    private CartService cut;\n    private ProductVerifier verifierMock;\n\n    @BeforeEach\n    void setUp() {\n        verifierMock = mock(ProductVerifier.class);\n        cut = new CartService(verifierMock);\n    }\n\n    @Test\n    void shouldAddProductToCart() {\n        when(verifierMock.isValid(\"42\")).thenReturn(true);\n        when(verifierMock.getDetails(\"42\")).thenReturn(\"MacBook Pro\");\n\n        String result = cut.addProductToCart(\"42\");\n\n        assertThat(result).isEqualTo(\"SUCCESS\");\n    }\n\n    @Test\n    void shouldThrowExceptionWhenProductIsNotValid() {\n        when(verifierMock.isValid(\"invalid\")).thenReturn(false);\n\n        assertThatThrownBy(() -> cut.addProductToCart(\"invalid\"))\n                .isInstanceOf(IllegalArgumentException.class)\n                .hasMessage(\"Not a valid product\");\n    }\n\n    @Test\n    void shouldVerifyLogging() {\n        when(verifierMock.isValid(\"42\")).thenReturn(true);\n        when(verifierMock.getDetails(\"42\")).thenReturn(\"MacBook Pro\");\n\n        try (MockedStatic<System> system = mockStatic(System.class)) {\n            cut.addProductToCart(\"42\");\n            system.verify(() -> System.out.println(\"Product added to cart: MacBook Pro\"));\n        }\n    }\n}",
    "description": "A service class for managing shopping cart operations, validating products before adding them to the cart and obtaining product details from a verifier component."
  },
  {
    "class": "public class OrderService {\n\n    private final OrderRepository orderRepository;\n    private final CustomerRepository customerRepository;\n    private final MailService mailService;\n\n    public OrderService(OrderRepository orderRepository, CustomerRepository customerRepository, MailService mailService) {\n        this.orderRepository = orderRepository;\n        this.customerRepository = customerRepository;\n        this.mailService = mailService;\n    }\n\n    public Order create(Order order) {\n\n        if (order.getCustomerId() == null) {\n            throw new OrderValidationException(\"Customer ID is required\");\n        }\n\n        Optional<Customer> customer = customerRepository.findById(order.getCustomerId());\n\n        if (customer.isEmpty()) {\n            throw new OrderValidationException(\"Customer does not exist\");\n        }\n\n        if (order.getItem() == null || order.getItem().isBlank()) {\n            throw new OrderValidationException(\"Item is required\");\n        }\n\n        order.setManaged(Boolean.TRUE);\n        order.setStatus(\"NEW\");\n        Order result = orderRepository.save(order);\n\n        mailService.sendMail(customer.get().getEmail(), \"Your order is being processed\");\n\n        return result;\n    }\n\n    public void update(String orderId, String newStatus) {\n        if (orderId == null || orderId.isBlank()) {\n            throw new OrderValidationException(\"Order ID is required\");\n        }\n\n        Optional<Order> order = orderRepository.findById(orderId);\n\n        if (order.isEmpty()) {\n            throw new OrderValidationException(\"Order does not exist\");\n        }\n\n        Order updatedOrder = order.get();\n        updatedOrder.setStatus(newStatus);\n\n        orderRepository.save(updatedOrder);\n    }\n}",
    "tests": "class OrderServiceTest {\n\n    private OrderService cut;\n    private OrderRepository orderRepositoryMock;\n    private CustomerRepository customerRepositoryMock;\n    private MailService mailServiceMock;\n\n    @BeforeEach\n    void setUp() {\n        orderRepositoryMock = mock(OrderRepository.class);\n        customerRepositoryMock = mock(CustomerRepository.class);\n        mailServiceMock = mock(MailService.class);\n        cut = new OrderService(orderRepositoryMock, customerRepositoryMock, mailServiceMock);\n    }\n\n    @Test\n    void shouldCreateNewOrder() {\n        Order orderToBeSaved = new Order();\n        orderToBeSaved.setCustomerId(\"42\");\n        orderToBeSaved.setItem(\"The Pragmatic Programmer\");\n\n        Order expected = new Order();\n        expected.setId(\"13\");\n        expected.setCustomerId(\"42\");\n        expected.setItem(\"The Pragmatic Programmer\");\n        expected.setStatus(\"NEW\");\n        expected.setManaged(true);\n\n        Customer customer = new Customer();\n        customer.setId(\"42\");\n        customer.setEmail(\"duke@java.io\");\n\n        when(customerRepositoryMock.findById(\"42\")).thenReturn(Optional.of(customer));\n        when(orderRepositoryMock.save(orderToBeSaved)).thenReturn(expected);\n\n        Order result = cut.create(orderToBeSaved);\n\n        assertThat(result).isEqualTo(expected);\n\n        verify(orderRepositoryMock).save(orderToBeSaved);\n        verify(mailServiceMock).sendMail(\"duke@java.io\", \"Your order is being processed\");\n    }\n\n    @Test\n    void shouldFailWhenThereIsNoCustomerId() {\n        Order order = new Order();\n        order.setItem(\"The Pragmatic Programmer\");\n\n        assertThatThrownBy(() -> cut.create(order))\n                .isInstanceOf(OrderValidationException.class)\n                .hasMessage(\"Customer ID is required\");\n\n        verifyNoInteractions(orderRepositoryMock);\n        verifyNoInteractions(mailServiceMock);\n    }\n\n    @Test\n    void shouldFailWhenThereIsNoCustomerForId() {\n        Order order = new Order();\n        order.setCustomerId(\"42\");\n        order.setItem(\"The Pragmatic Programmer\");\n\n        when(customerRepositoryMock.findById(\"42\")).thenReturn(Optional.empty());\n\n        assertThatThrownBy(() -> cut.create(order))\n                .isInstanceOf(OrderValidationException.class)\n                .hasMessage(\"Customer does not exist\");\n\n        verifyNoInteractions(orderRepositoryMock);\n        verifyNoInteractions(mailServiceMock);\n    }\n\n    @Test\n    void shouldFailWhenThereIsNoItem() {\n        Order order = new Order();\n        order.setCustomerId(\"42\");\n\n        Customer customer = new Customer();\n        customer.setId(\"42\");\n\n        when(customerRepositoryMock.findById(\"42\")).thenReturn(Optional.of(customer));\n\n        assertThatThrownBy(() -> cut.create(order))\n                .isInstanceOf(OrderValidationException.class)\n                .hasMessage(\"Item is required\");\n\n        verifyNoInteractions(orderRepositoryMock);\n        verifyNoInteractions(mailServiceMock);\n    }\n\n    @Test\n    void shouldUpdateAnOrder() {\n        Order existingOrder = new Order();\n        existingOrder.setId(\"42\");\n        existingOrder.setCustomerId(\"1337\");\n        existingOrder.setItem(\"Spring Boot Cookbook\");\n        existingOrder.setStatus(\"NEW\");\n\n        when(orderRepositoryMock.findById(\"42\")).thenReturn(Optional.of(existingOrder));\n\n        cut.update(\"42\", \"PROCESSING\");\n\n        verify(orderRepositoryMock).findById(\"42\");\n        verify(orderRepositoryMock).save(existingOrder);\n\n        assertThat(existingOrder.getStatus()).isEqualTo(\"PROCESSING\");\n    }\n\n    @Test\n    void shouldFailToUpdateWhenOrderIdIsNotPresent() {\n        assertThatThrownBy(() -> cut.update(null, \"PROCESSING\"))\n                .isInstanceOf(OrderValidationException.class)\n                .hasMessage(\"Order ID is required\");\n\n        verifyNoInteractions(orderRepositoryMock);\n    }\n\n    @Test\n    void shouldFailToUpdateWhenOrderIdIsBlank() {\n        assertThatThrownBy(() -> cut.update(\"\", \"PROCESSING\"))\n                .isInstanceOf(OrderValidationException.class)\n                .hasMessage(\"Order ID is required\");\n\n        verifyNoInteractions(orderRepositoryMock);\n    }\n\n    @Test\n    void shouldFailToUpdateWhenOrderDoesNotExist() {\n        when(orderRepositoryMock.findById(\"42\")).thenReturn(Optional.empty());\n\n        assertThatThrownBy(() -> cut.update(\"42\", \"PROCESSING\"))\n                .isInstanceOf(OrderValidationException.class)\n                .hasMessage(\"Order does not exist\");\n\n        verify(orderRepositoryMock).findById(\"42\");\n        verifyNoMoreInteractions(orderRepositoryMock);\n    }\n}",
    "description": "An order service that manages the creation and updating of customer orders with validation for required fields, customer existence, and notifies customers via email when orders are being processed."
  },
  {
    "class": "public class SomeService {\n\n    private final SomeRepositoryInterface repository;\n\n    public SomeService(SomeRepositoryInterface repository) {\n        this.repository = repository;\n    }\n\n    public String handle(String input) {\n        if (input == null || input.isBlank()) {\n            throw new IllegalArgumentException(\"Input is required\");\n        }\n\n        return repository.persist(input);\n    }\n}",
    "tests": "class SomeServiceTest {\n\n    private SomeService cut;\n    private SomeRepositoryInterface repositoryMock;\n\n    @BeforeEach\n    void setUp() {\n        repositoryMock = mock(SomeRepositoryInterface.class);\n        cut = new SomeService(repositoryMock);\n    }\n\n    @Test\n    void shouldReturnTheExpectedResult() {\n        when(repositoryMock.persist(\"Duke\")).thenReturn(\"Hello Duke\");\n\n        String result = cut.handle(\"Duke\");\n\n        assertThat(result).isEqualTo(\"Hello Duke\");\n    }\n\n    @Test\n    void shouldThrowExceptionWhenInputIsNull() {\n        assertThatThrownBy(() -> cut.handle(null))\n                .isInstanceOf(IllegalArgumentException.class)\n                .hasMessage(\"Input is required\");\n\n        verifyNoInteractions(repositoryMock);\n    }\n\n    @Test\n    void shouldThrowExceptionWhenInputIsBlank() {\n        assertThatThrownBy(() -> cut.handle(\"  \"))\n                .isInstanceOf(IllegalArgumentException.class)\n                .hasMessage(\"Input is required\");\n\n        verifyNoInteractions(repositoryMock);\n    }\n}",
    "description": "A simple service class that validates input and delegates persistence operations+(\\\\.[_A-Za-z0-9-]+)*@\" +\n        \"[A-Za-z0-9-]+(\\\\.[A-Za-z0-9]+)*(\\\\.[A-Za-z]{2,})$\";\n    \n    private static final Pattern pattern = Pattern.compile(EMAIL_PATTERN);\n    \n    public boolean isValidEmail(String email) {\n        if (email == null) {\n            return false;\n        }\n        \n        Matcher matcher = pattern.matcher(email);\n        return matcher.matches();\n    }\n}"
  },
  {
    "class": "public class PasswordValidator {\n    private static final int MIN_LENGTH = 8;\n    \n    public boolean isValid(String password) {\n        if (password == null || password.length() < MIN_LENGTH) {\n            return false;\n        }\n        \n        boolean hasLowerCase = false;\n        boolean hasUpperCase = false;\n        boolean hasDigit = false;\n        boolean hasSpecialChar = false;\n        \n        for (char c : password.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                hasLowerCase = true;\n            } else if (Character.isUpperCase(c)) {\n                hasUpperCase = true;\n            } else if (Character.isDigit(c)) {\n                hasDigit = true;\n            } else if (isSpecialChar(c)) {\n                hasSpecialChar = true;\n            }\n        }\n        \n        return hasLowerCase && hasUpperCase && hasDigit && hasSpecialChar;\n    }\n    \n    private boolean isSpecialChar(char c) {\n        return !Character.isLetterOrDigit(c) && !Character.isWhitespace(c);\n    }\n}",
    "tests": "public class PasswordValidatorTest {\n    private PasswordValidator validator;\n    \n    @Before\n    public void setUp() {\n        validator = new PasswordValidator();\n    }\n    \n    @Test\n    public void testValidPassword() {\n        assertTrue(validator.isValid(\"Passw0rd!\"));\n        assertTrue(validator.isValid(\"Secure1Pass@\"));\n        assertTrue(validator.isValid(\"Complex_P4ssword\"));\n    }\n    \n    @Test\n    public void testInvalidPasswords() {\n        // Too short\n        assertFalse(validator.isValid(\"Pw1@\"));\n        \n        // No lowercase\n        assertFalse(validator.isValid(\"PASSWORD1!\"));\n        \n        // No uppercase\n        assertFalse(validator.isValid(\"password1!\"));\n        \n        // No digit\n        assertFalse(validator.isValid(\"Password!\"));\n        \n        // No special character\n        assertFalse(validator.isValid(\"Password1\"));\n        \n        // Null password\n        assertFalse(validator.isValid(null));\n    }\n}",
    "description": "A password validator that checks if a password meets security requirements including minimum length, lowercase letters, uppercase letters, digits, and special characters."
  },
  {
    "class": "public final class MathUtils {\n    private MathUtils() {\n        // Private constructor to prevent instantiation\n    }\n    \n    public static int factorial(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"Factorial is not defined for negative numbers\");\n        }\n        if (n > 12) {\n            throw new IllegalArgumentException(\"Input too large, may cause integer overflow\");\n        }\n        \n        int result = 1;\n        for (int i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n    \n    public static boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        if (n <= 3) {\n            return true;\n        }\n        if (n % 2 == 0 || n % 3 == 0) {\n            return false;\n        }\n        \n        for (int i = 5; i * i <= n; i += 6) {\n            if (n % i == 0 || n % (i + 2) == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public static int gcd(int a, int b) {\n        if (a == 0 && b == 0) {\n            throw new IllegalArgumentException(\"GCD is not defined for both inputs being zero\");\n        }\n        a = Math.abs(a);\n        b = Math.abs(b);\n        \n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}",
    "tests": "public class MathUtilsTest {\n    \n    @Test\n    public void testFactorial() {\n        assertEquals(1, MathUtils.factorial(0));\n        assertEquals(1, MathUtils.factorial(1));\n        assertEquals(2, MathUtils.factorial(2));\n        assertEquals(6, MathUtils.factorial(3));\n        assertEquals(24, MathUtils.factorial(4));\n        assertEquals(120, MathUtils.factorial(5));\n        assertEquals(479001600, MathUtils.factorial(12));\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testFactorialNegative() {\n        MathUtils.factorial(-1);\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testFactorialTooLarge() {\n        MathUtils.factorial(13);\n    }\n    \n    @Test\n    public void testIsPrime() {\n        assertFalse(MathUtils.isPrime(0));\n        assertFalse(MathUtils.isPrime(1));\n        assertTrue(MathUtils.isPrime(2));\n        assertTrue(MathUtils.isPrime(3));\n        assertFalse(MathUtils.isPrime(4));\n        assertTrue(MathUtils.isPrime(5));\n        assertFalse(MathUtils.isPrime(6));\n        assertTrue(MathUtils.isPrime(7));\n        assertFalse(MathUtils.isPrime(9));\n        assertTrue(MathUtils.isPrime(11));\n        assertTrue(MathUtils.isPrime(13));\n        assertFalse(MathUtils.isPrime(15));\n        assertTrue(MathUtils.isPrime(17));\n        assertTrue(MathUtils.isPrime(19));\n        assertTrue(MathUtils.isPrime(23));\n        assertTrue(MathUtils.isPrime(29));\n        assertFalse(MathUtils.isPrime(39));\n        assertTrue(MathUtils.isPrime(97));\n    }\n    \n    @Test\n    public void testGcd() {\n        assertEquals(5, MathUtils.gcd(5, 0));\n        assertEquals(5, MathUtils.gcd(0, 5));\n        assertEquals(1, MathUtils.gcd(7, 13));\n        assertEquals(6, MathUtils.gcd(30, 24));\n        assertEquals(6, MathUtils.gcd(-30, 24));\n        assertEquals(6, MathUtils.gcd(30, -24));\n        assertEquals(6, MathUtils.gcd(-30, -24));\n        assertEquals(7, MathUtils.gcd(7, 7));\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testGcdBothZero() {\n        MathUtils.gcd(0, 0);\n    }\n}",
    "description": "A utility class for mathematical operations including factorial calculation with range validation, primality testing using an optimized algorithm, and greatest common divisor (GCD) computation using the Euclidean algorithm."
  },
  {
    "class": "public class DateUtils {\n    \n    public boolean isLeapYear(int year) {\n        if (year % 400 == 0) {\n            return true;\n        }\n        if (year % 100 == 0) {\n            return false;\n        }\n        return year % 4 == 0;\n    }\n    \n    public int getDaysInMonth(int month, int year) {\n        if (month < 1 || month > 12) {\n            throw new IllegalArgumentException(\"Month must be between 1 and 12\");\n        }\n        \n        if (month == 2) {\n            return isLeapYear(year) ? 29 : 28;\n        }\n        \n        if (month == 4 || month == 6 || month == 9 || month == 11) {\n            return 30;\n        }\n        \n        return 31;\n    }\n}",
    "tests": "public class DateUtilsTest {\n    private DateUtils dateUtils;\n    \n    @Before\n    public void setUp() {\n        dateUtils = new DateUtils();\n    }\n    \n    @Test\n    public void testIsLeapYear() {\n        // Years divisible by 400 are leap years\n        assertTrue(dateUtils.isLeapYear(2000));\n        assertTrue(dateUtils.isLeapYear(1600));\n        \n        // Years divisible by 100 but not by 400 are not leap years\n        assertFalse(dateUtils.isLeapYear(1900));\n        assertFalse(dateUtils.isLeapYear(2100));\n        \n        // Years divisible by 4 but not by 100 are leap years\n        assertTrue(dateUtils.isLeapYear(2004));\n        assertTrue(dateUtils.isLeapYear(2008));\n        assertTrue(dateUtils.isLeapYear(2012));\n        assertTrue(dateUtils.isLeapYear(1996));\n        \n        // Years not divisible by 4 are not leap years\n        assertFalse(dateUtils.isLeapYear(2001));\n        assertFalse(dateUtils.isLeapYear(2002));\n        assertFalse(dateUtils.isLeapYear(2003));\n        assertFalse(dateUtils.isLeapYear(1997));\n    }\n    \n    @Test\n    public void testGetDaysInMonth() {\n        // February in leap years has 29 days\n        assertEquals(29, dateUtils.getDaysInMonth(2, 2020));\n        assertEquals(29, dateUtils.getDaysInMonth(2, 2000));\n        assertEquals(29, dateUtils.getDaysInMonth(2, 2016));\n        \n        // February in non-leap years has 28 days\n        assertEquals(28, dateUtils.getDaysInMonth(2, 2019));\n        assertEquals(28, dateUtils.getDaysInMonth(2, 1900));\n        assertEquals(28, dateUtils.getDaysInMonth(2, 2001));\n        \n        // Months with 30 days\n        assertEquals(30, dateUtils.getDaysInMonth(4, 2020));\n        assertEquals(30, dateUtils.getDaysInMonth(6, 2020));\n        assertEquals(30, dateUtils.getDaysInMonth(9, 2020));\n        assertEquals(30, dateUtils.getDaysInMonth(11, 2020));\n        \n        // Months with 31 days\n        assertEquals(31, dateUtils.getDaysInMonth(1, 2020));\n        assertEquals(31, dateUtils.getDaysInMonth(3, 2020));\n        assertEquals(31, dateUtils.getDaysInMonth(5, 2020));\n        assertEquals(31, dateUtils.getDaysInMonth(7, 2020));\n        assertEquals(31, dateUtils.getDaysInMonth(8, 2020));\n        assertEquals(31, dateUtils.getDaysInMonth(10, 2020));\n        assertEquals(31, dateUtils.getDaysInMonth(12, 2020));\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testGetDaysInMonthWithInvalidMonth() {\n        dateUtils.getDaysInMonth(0, 2020);\n    }\n    \n    @Test(expected = IllegalArgumentException.class)\n    public void testGetDaysInMonthWithInvalidMonthUpperBound() {\n        dateUtils.getDaysInMonth(13, 2020);\n    }\n}",
    "description": "A utility class for date-related operations that calculates if a year is a leap year according to the Gregorian calendar rules and determines the number of days in a specific month considering leap years."
  }
]