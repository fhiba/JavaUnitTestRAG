# AutoTestRAG

## Project Description

The main idea is to build a tool that, given the source file of a Java class and its project context, automatically generates a relevant set of unit tests. We use a Retrieval-Augmented Generation (RAG) approach: for an input class, we retrieve semantically similar classes from a vector database built on real GitHub projects.

##  Overview

AutoTestRAG simplifies unit test creation by combining:

1. **Retrieval**: Java classes (with their descriptions and existing tests) are embedded and stored in a vector database populated from open-source GitHub repositories.  
2. **Generation**: An LLM is prompted with retrieved examples plus the target class to generate coherent, functional JUnit tests.

**Key features:**
- Context-aware test generation, considering project path and dependencies.  
- Configurable retrieval (e.g., top‑k similar neighbors).  
- Outputs as code blocks or standalone `.py`/`.java` test files.

##  Input & Output

- **Input**:  
  - Path to the target Java class source file.  
  - Project root path for additional context.  

- **Output**:  
  A file or code block containing the generated unit tests for the target class.

##  Vector DB Persistence

In the vector database we store embeddings of textual descriptions of Java classes. Each record includes:
- A brief functional description (auto‑generated by the LLM).  
- The class source code as text.  
- The existing set of unit tests associated with that class.

These descriptions facilitate semantic search of similar classes.

##  Data Sources & Format

- **Sources**: Open‑source projects on GitHub with good test coverage, including:
  - https://github.com/DanAg278/Java-Unit-Testing  
  - https://github.com/christian-kesler/junit-testing-java  
  - https://github.com/rieckpil/java-testing-toolbox  

- **Format**: JSON array of objects:
  ```json
  [
    {
      "class": "<Java class source>",
      "tests": "<JUnit test source>",
      "description": "<Brief functional description>"
    }
  ]
  ```

##  Challenges

The main challenge is ensuring the model generates not only syntactically correct tests but also tests that are functionally coherent with the class’s expected behavior. This requires:
- Effective retrieval of relevant examples.  
- Handling of dependencies, mocks, and varying testing styles across projects.  
- Robust semantic representation of classes for accurate neighbors.

## Getting Started

### Prerequisites

- Python 3.8+  
- pip  
- Access to an LLM endpoint (e.g., OpenAI API key)  
- Pinecone (or FAISS) vector database

### Installation

```bash
git clone https://github.com/fhiba/JavaUnitTestRAG.git
cd AutoTestRAG
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```

### Usage

```bash
# 1) Direct-LLM mode (no RAG retrieval):
python RAG.py /path/to/MyClass.java

# 2) RAG + Pinecone retrieval (requires PINECONE_API_KEY & PINECONE_INDEX_NAME in your env):
python RAG.py /path/to/MyClass.java --use_rag

# 3) RAG + reranking (adds cross-encoder rerank on top of --use_rag):
python RAG.py /path/to/MyClass.java --use_rag --rerank
```

##  Authors

This project was developed by **Group 4** as part of the Deep Learning course at ITBA:

- Felipe Hiba
- Patricio Escudeiro
- Jose Burgos
